// DO NOT EDIT THIS FILE DIRECTLY
// This file is used to autogenerate the alarm configuration files for new service alarm configurations.

import * as path from 'node:path';
import * as fs from 'node:fs';
import * as readline from 'node:readline';

const ALARM_CONFIG_TEMPLATE = `
// THIS FILE WAS AUTOGENERATED VIA ./_template-configs.mts
// See file for instructions on how to generate new alarm config files.
/**
 * @fileoverview [SERVICE_NAME] alarm configuration definitions.
 *
 * This file contains the default configurations for all supported [SERVICE_NAME] CloudWatch alarms managed by AutoAlarm.
 *
 * ---
 *
 * @usage
 * The MetricAlarm interface {@link MetricAlarmConfig} contained in this list are strongly typed, specifically in the defaults object for
 *  * statistic
 *  * comparisonOperator
 *  * missingDataTreatment
 *
 *  It is strongly encouraged to use the following utilities/enums to populate values for the following fields which
 *  provide thorough TSDOC and autocomplete. However, you may also use string literals:
 *   * \`comparisonOperator\` - Use the AWS SDK enums for comparison operators {@link ComparisonOperator}
 *   * \`missingDataTreatment\` - Use the AWS SDK enums for missing data treatment {@link TreatMissingData}
 *
 * These are demonstrated in the examples below.
 *
 * ---
 *
 * @instructions
 * ### Adding to a current alarm configuration in this file
 * 1. Create a new alarm config file if it does not exist by running in the project root the following:
      \`pnpm create-cw-configs [serviceName] [Team name that owns the Alarms]\`
 * 2. Add the new configuration to the [SERVICE_NAME] array
 * 3. Ensure the \`tagKey\` follows the tag key naming conventions in the README. Does not include 'autoalarm' (e.g. 5xx-count-anomaly)
 * 4. Set appropriate default values for all required fields
 * 5. Use the AWS SDK enums for comparison operators {@link ComparisonOperator} and missing data treatment {@link TreatMissingData}
 *
 * ---
 *
 * @requires
 * - Approval from Owners Team lead and consultation before adding new alarms
 * - Anomaly Alarms can only use the following comparison operators: GreaterThanUpperThreshold, LessThanLowerOrGreaterThanUpperThreshold, LessThanLowerThreshold
 *
 * ---
 *
 * @example
 * \`\`\`typescript
 * // Adding a new EC2 alarm configuration to configs file
 * export const _EC2Configs: MetricAlarmConfig[] = [ // only create the configs array if it does not exist
 *                                                             // Otherwise add to the existing array following the
 *                                                             // pattern below
 * {
 *   tagKey: 'new-metric-alarm',                          // Unique identifier
 *   metricName: 'MetricName',                            // CloudWatch metric name
 *   metricNamespace: 'AWS/EC2',
 *   defaultCreate: false,                                // Whether to create by default
 *   anomaly: false,                                      // Whether this is anomaly detection
 *   defaults: {
 *     warningThreshold: 100,                             // Warning threshold (null if not used)
 *     criticalThreshold: 200,                            // Critical threshold (null if not used)
 *     period: 60,                                        // Period in seconds
 *     evaluationPeriods: 2,                              // Evaluation periods
 *     statistic: Average,           
 *     dataPointsToAlarm: 2,                              // Data points required to alarm
 *     comparisonOperator: ComparisonOperator.GREATER_THAN_THRESHOLD, // Comparison operator
 *     missingDataTreatment: TreatMissingData.IGNORE,                    // How to treat missing data
 *   },
 * },
 * ---
 *
 * @Owners [TEAM_NAME]
 */
 
import {
  MetricAlarmConfig,
} from '#types/alarm-config-types.mjs';
import {ComparisonOperator} from '@aws-sdk/client-cloudwatch';
import {TreatMissingData} from 'aws-cdk-lib/aws-cloudwatch';

/**
 * _[SERVICE_NAME] alarm configuration definitions.
 * Implements the {@link MetricAlarmConfig} interface.
 * Used to map a tag key to a CloudWatch metric name and namespace to default alarm configurations {@link MetricAlarmOptions}.
 */
export const _[SERVICE_NAME]: MetricAlarmConfig[] = [
  {
    tagKey: '[TAG_KEY]',
    metricName: '[METRIC_NAME]',
    metricNamespace: 'AWS/[NAME_SPACE]',
    defaultCreate: [BOOLEAN],
    anomaly: [BOOLEAN], // Static threshold if false, anomaly detection if true
    defaults: {
      warningThreshold: [NUMBER_OR_NULL],
      criticalThreshold: [NUMBER_OR_NULL],
      period: [NUMBER],
      evaluationPeriods: [NUMBER],
      statistic: [STATISTIC],  
      dataPointsToAlarm: [NUMBER],
      comparisonOperator: [COMPARISON_OPERATOR], // Use ComparisonOperator enum (e.g., ComparisonOperator.GreaterThanThreshold)
      missingDataTreatment: [MISSING_DATA_TREATMENT],   // Use TreatMissingData enum (e.g., TreatMissingData.IGNORE)
    },
  },
  {
    tagKey: '[TAG_KEY]',
    metricName: '[METRIC_NAME]',
    metricNamespace: 'AWS/[NAME_SPACE]',
    defaultCreate: [BOOLEAN],
    anomaly: [BOOLEAN], // Static threshold if false, anomaly detection if true
    defaults: {
      warningThreshold: [NUMBER_OR_NULL],
      criticalThreshold: [NUMBER_OR_NULL],
      period: [NUMBER],
      evaluationPeriods: [NUMBER],
      statistic: [STATISTIC], 
      dataPointsToAlarm: [NUMBER],
      comparisonOperator: [COMPARISON_OPERATOR], // Use ComparisonOperator enum (e.g., ComparisonOperator.GreaterThanThreshold)
      missingDataTreatment: [MISSING_DATA_TREATMENT],   // Use TreatMissingData enum (e.g., TreatMissingData.IGNORE)
    },
  // add more as needed
 ];
 `;

function toKebabCase(input: string): string {
  return input
    .toLowerCase()
    // Replace underscores and spaces with hyphens
    .replace(/[_\s]/g, '-')
    // Insert hyphens between camelCase boundaries
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .toLowerCase()
    // Clean up any double hyphens that might have been created
    .replace(/-+/g, '-');
}

// Function to update the barrel file with a new service in alphabetical order
function updateBarrelFile(upperServiceName: string, kebabServiceName: string): void {
  const barrelFilePath = './handlers/src/alarm-config/cloudwatch-alarms/_index.mts';

  try {
    // Read the current barrel file
    const barrelContent = fs.readFileSync(barrelFilePath, 'utf8');

    // Check if this service is already in the barrel file
    if (barrelContent.includes(`_${upperServiceName}`)) {
      console.log(`Service ${upperServiceName} is already in the barrel file. No update needed.`);
      return;
    }

    // Split the file into sections
    const docSection = barrelContent.substring(barrelContent.indexOf('/**'), barrelContent.indexOf('\n',barrelContent.indexOf('*/'))+ 1);
    const importsEndIndex = barrelContent.indexOf('import {MetricAlarmConfigs}');
    const metricImportLine = barrelContent.substring(importsEndIndex, barrelContent.indexOf('\n', importsEndIndex) + 1);

    // Extract all import statements
    const importSection = barrelContent.substring(barrelContent.indexOf('import {_'), importsEndIndex);
    const importLines = importSection.split('\n').filter(line => line.trim().length > 0);

    // Create the new import statement
    const newImportStatement = `import {_${upperServiceName}} from '#alarms/${kebabServiceName}-configs.mjs';`;

    // Add the new import
    importLines.push(newImportStatement);

    // Sort alphabetically
    importLines.sort();

    // Extract the AlarmConfigs object
    const configObjectStart = barrelContent.indexOf('export const AlarmConfigs');
    const configObjectEnd = barrelContent.indexOf('} as const', configObjectStart);

    // Extract existing entries
    const configObjectContent = barrelContent.substring(configObjectStart, configObjectEnd);
    const configEntryLines = configObjectContent
      .split('\n')
      .slice(1) // Skip the first line which is the declaration
      .filter(line => line.trim().length > 0 && line.includes(':'));

    // Add the new entry
    const newConfigEntry = `  ${upperServiceName}: [..._${upperServiceName}],`;
    configEntryLines.push(newConfigEntry);

    // Sort the entries alphabetically
    configEntryLines.sort();

    // Rebuild the config object
    const newConfigObject =
      'export const AlarmConfigs: MetricAlarmConfigs = {\n' +
      configEntryLines.join('\n') +
      '\n} as const';

    // Get the remainder of the file (if any)
    const remainder = barrelContent.substring(barrelContent.indexOf('} as const') + 10);

    // Build the new file content
    const newContent =
      docSection +
      importLines.join('\n') +
      '\n' +
      metricImportLine +
      '\n' +
      '// Create a single object to export all alarm configurations\n' +
      newConfigObject +
      remainder;

    // Write the updated barrel file
    fs.writeFileSync(barrelFilePath, newContent);
    console.log(`Updated barrel file with ${upperServiceName} alarm configs in alphabetical order`);

  } catch (error) {
    console.error(`Error updating barrel file: ${error}`);
  }
}

// Function to create a file with the template
function createTemplateFile(serviceName: string, teamName: string): void {
  // Format service name for different uses
  const upperServiceName = serviceName.toUpperCase()
    .replace(/-/g, '_');
  const kebabServiceName = toKebabCase(serviceName);
  const upperTeamName = teamName.toUpperCase();

  // Replace placeholders in template
  const fileContent =
    // Replace File creation instructions
    ALARM_CONFIG_TEMPLATE.replace(/\[SERVICE_NAME\]/g, upperServiceName)
      .replace(/\[service-name\]/g, kebabServiceName)
      .replace(/\[TEAM_NAME\]/g, upperTeamName)

  // Create file name
  const fileName = `${kebabServiceName}-configs.mts`;
  const filePath = path.join(
    './handlers/src/alarm-config/cloudwatch-alarms/',
    fileName,
  );

  // Check if file already exists
  if (fs.existsSync(filePath)) {
    console.error(`Error: File already exists at ${filePath}`);
    return;
  }

  // Create the directory if it doesn't exist
  const dirPath = path.dirname(filePath);
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }

  // Write the file
  fs.writeFileSync(filePath, fileContent);
  console.log(`Created ${fileName} with template for ${upperServiceName} alarms in ${filePath}`);

  // Now update the barrel file
  updateBarrelFile(upperServiceName, kebabServiceName);
}

// Interactive prompt for CLI
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

// Get the service name from command line arguments or prompt
const args = process.argv.slice(2);
if (args.length >= 2) {
  // Get the service name and team name from command line
  const serviceName = args[0];
  const teamName = args[1];
  createTemplateFile(serviceName, teamName);
  rl.close();
} else if (args.length === 1) {
  // Get the service name from command line and prompt for team name
  const serviceName = args[0];
  rl.question(
    'Enter the name of the Team that owns these alarms: ',
    (teamName) => {
      createTemplateFile(serviceName, teamName);
      rl.close();
    }
  );
} else {
  // Prompt for input
  rl.question(
    'Enter the AWS service name (e.g., EC2, Lambda): ',
    (serviceName: string) => {
      rl.question(
        'Enter the name of the Team that owns these alarms: ',
        (teamName) => {
          createTemplateFile(serviceName, teamName);
          rl.close();
        },
      );
    },
  );
}

